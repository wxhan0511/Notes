# 日志

## 2025-7-17

- 电源增强板 i2c通信
- 准备另外一台不连内网主机使用盗版keil烧录程序

//
<details>❌问题1:i2c主机进入从机发起的EXTI中断后uart_send函数没有打印
<summary>❌ 原始问题代码</summary>
if (osMutexAcquire(uart_mutex, osWaitForever) == osOK)
{
    HAL_UART_Transmit(&huart1, (uint8_t*)str, strlen(str), 100);
    osMutexRelease(uart_mutex);
}

</details>解决方案1:中断中不可以用互斥锁和信号量
## 🚨 为什么中断中不能使用互斥锁和信号量？
互斥锁设计用于任务间同步
需要任务调度器的支持
中断是异步的，不参与任务调度
# 📚 IPSR寄存器详解
ARM Cortex-M 程序状态寄存器 (PSR)
┌─────────────────────────────────────┐
│            PSR (32-bit)             │
├──────────────┬──────────────────────┤
│ APSR[31:27]  │    Reserved[26:24]   │  <- 应用程序状态
├──────────────┼──────────────────────┤
│    Reserved[23:10]                  │
├─────────────────────────────────────┤
│         IPSR[8:0]                   │  <- 中断状态（这里！）
└─────────────────────────────────────┘
线程模式 → 中断发生 → 硬件自动更新IPSR
┌──────────┐    中断触发    ┌──────────┐
│ IPSR = 0 │ ─────────────→ │IPSR = IRQ│
│(任务执行) │               │ 号 + 16  │
└──────────┘               └──────────┘
                                    │
                            中断返回 │
                                    ↓
                                ┌──────────┐
                                │ IPSR = 0 │
                                │(恢复任务) │
                                └──────────┘



</details>问题2:HAL_GetTick()计数值不变导致卡死
while (HAL_GetTick() - tick_start < timeout)
{
    if (HAL_I2C_GetState(hi2c) == HAL_I2C_STATE_READY)
    {
        return HAL_OK;
    }
}
</details>

</details>解决方案2:SysTick 中断优先级问题
RTOS里面,我们需要使用 SysTick 来提供系统时基, HAL_GetTick()这个函数，用于实现延时以及外设驱动的超时判断。
这个函数主要是靠不断读取SysTick计数器的值来实现延迟。
但是加入了RTOS之后，RTOS强制将systick的中断设置为最低，#define TICK_INT_PRIORITY 15U 表示SysTick定时器中断优先级为15，
在STM32 NVIC优先级体系中，数值越大优先级越低，所以15是最低优先级（0是最高）。
假设在一个中断优先级比systick高的中断int_a中调用HAL_GetTick()，
那么由于int_a中断优先级高于systick，从而导致systick无法抢占，也就无法增加计数器的值，
就会导致int_a中断服务函数死等HAL_GetTick()，无法退出，从而造成比int_a优先级低的中断服务都无法使用，系统也无法调度。
</details>



</details>问题3：新增.c和.h,cubeIDE找不到
</details>

</details>解决方案：CMAKE RECONFIGURE

## 2025-7-18

- 准备另外一台不连内网主机使用盗版keil烧录程序

</details>问题1:对拷线驱动安装

</details>解决方案:暂无,kaspersky阻止安装


</details>问题2:VSCODE SFR寄存器无法直观展示

</details>解决方案：暂无


</details>I2C教程
HAL_I2C_Master_Transmit
1. 等待busy_flag为0:start后,stop前为1                                         (总线被拉低)
2. 发start,写入地址,等待addrflag为1:发送完成且收到ACK  然后清除addrflag         (发送地址后无ACK)
主循环
3.等待TXE为1:发送数据寄存器（DR）为空
   - 若TXE为0时收到NACK,则清除NACK_FLAG,发送stop并返回错误
   - 若TXE为1,则继续step4
4. 写入DR寄存器
5. 如果BTF为1:（发送数据寄存器空）且数据已完全发送到总线
6. 继续写入DR寄存器
7. 等待BTF为1:（发送数据寄存器空）且数据已完全发送到总线
8. 继续写入DR寄存器
9. 重复步骤3-8直到所有数据发送完毕
10. 发送STOP


## 2025-7-21

- keil使用ST link烧录底板程序 已完成
- GC4.0和底板i2c通信,并能在i2c总线上抓到发给电源增强板的波形 进度10%
<details>
  熟悉和修改ae_tool_mother_board_project_5_38_07(1)
  1.GC4.0帧头改为0xF3/0xF4
  2.void sample_command_handle(master_state_t* state,const uint8_t* data){
    meter_v2_msg_t msg;
    osDelay(100);
    if(data[0] == 0xf2)
    {
        msg.id = 1;
    }
    else if(data[0] == 0xf3)
    {
        msg.id = 2;
    }
    //帧头修改为0xF3/0xF4,这个电源增强版忽略
    if(data[1] == 0x20 && data[2] == 0x0b) {
        printf("test freq\r\n");
        meter_freq_sample(data[0]);
    }else
    {
        memcpy(msg.data,data,64);
        msg.data[0] = 0xf8;
        //压入队列,电源增强版要压入它的队列
        const osStatus_t status = notify_meter(&msg);
        // printf("id 0x%x;",msg.id);
        // for (uint8_t i = 0; i < 10; i++)
        //     printf("0x%x ", msg.data[i]);
        //printf("\r\n");
        //wxhan:判断采样板是否在忙,忙的话报错给GC4.0
        if(status != osOK){
            printf("notify meter error %d \r\n",status);
            msg.data[2] = 0x01;
            USBD_HID_GetReportTrigger(1U, 0U, msg.data, 64U);
        }
    }
    //
}
   3.app_meter_v2_run见函数内注释
</details>


## 2025-7-22
- GC4.0和底板i2c通信,并能在i2c总线上抓到发给电源增强板的波形 进度100%
<details>
    1.lcd_cmd_handle 处理收到的GC4.0命令
    2.压入RA_POWEREX_msg_queue
    3.app_meter_v2_run线程 get队列数据去处理
</details>

## 2025-7-23
- GC4.0和底板i2c通信,电源增强板通信 100%
## 2025-7-24
- - GC4.0和底板i2c通信,电源增强板通信协议实现 进度30%
## 2025-7-25
- - GC4.0和底板i2c通信,电源增强板通信协议实现
## 2025-7-28
- - GC4.0和底板i2c通信,电源增强板通信协议实现
-- MCU pinRX TX 到转接排插RX，TX接反
-- GC4.0点击太快会卡死在while循环里,电源增强版接收失败,底板程序仍然往下走 解决：压入消息队列，结束本次while循环
## 2025-7-29
-- 电源增强板通信协议实现

## 2025-7-31

## 2025-08-06

## 2025-08-11
1、解决档位切换不成功问题 100%
2、显示部事业部会议
3、RA_POWEREX板验证
    3.1 电压设定
    3.2 电流采样
## 2025-10-29
1、CDC调试🏁
2、CDC对比查看之前为什么不通🔄
3、购买得力电动螺丝刀,目前不太需要，暂时搁置🕒
4、发货yan，已发两单，明天还需发一单🔄
5、初版电源增强版校准🏁
## 2025-10-30
CDC对比查看之前为什么不通🏁
发货yan，已发两单，还需发一单🏁
RAXB电源设定🏁
## 2025-10-31
调试XB i2c sda线拉不高，更换XB后ok🏁
调试和学习USB复合设备，CDC和CHID切换正常🔄
## 2025-11-3
RA XB电源开关异常，发现控制寄存器读为FF，更换库函数读🔄
RA增强板 ELVDD无输出，🔄
## 2025-11-4
调试好RA增强版CDC协议
## 2025-11-5
增加RA增强板电源上电时序
解决RA增强板恢复上一次电压的bug
排查有问题的硬件,ELVSS电压不输出和ELVDD上电时序错误
## 2025-11-6
VCC和ELVDD重新上电后,电压比上一次设置低的问题,更换板子后解决
调试RA增强板14个用于投炉
组内例会1h
开发USB复合设备
BUG：大板12V没电
    DA芯片MCP4728通道1（ELVSS）无输出，导致最终ELVSS电压为0
    ELVDD在10s后等待第二次低电平使能失败
    VCC、IOCC经软件校准后输出偏差100%以上，其他RA增强板无此问题
## 2025-11-7
USB CDC和HID复合设备开发
解决RA增强板FLASH读取出错的bug（添加等待（W25Q256JVEQ）FLASH BUSY清零）
## 2025-11-10
解决ADS1256通道AIN0偶然错误读到0的问题
USB CDC和HID复合设备开发
## 2025-11-11
USB CDC和HID复合设备开发 开发完成🏁
## 2025-11-12
GTB功能進行中
## 2025-11-13
GTB功能進行中

